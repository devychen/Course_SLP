"""
Course:        Statistical Language Processing - Summer 2024
Assignment:    (Enter the assignment number - e.g. A1)
Author(s):     (Enter the full names of author(s) here)

Honor Code:    I/We pledge that this program represents my/our own work,
               and that I/we have not given or received unauthorized help
               with this assignment.
"""

import torch
from sklearn.metrics import classification_report
from trainer import FeedForwardNet
from constants import *


class Evaluator:
    def __init__(self):
        """
        Class for loading a Feedforward Network from file, and evaluating
        on test data also loaded from file.

        Public methods include:
            - load_model()
            - load_data()
            - evaluate()
        """
        self.model = None
        self.X_test = None
        self.y_test = None
        self.label_map = None

    def load_model(self, model_file):
        """
        Loads the model in model_file and saves it in self.model.

        - Load model_file, which contains a dictionary
          as saved with Trainer.save_best_model()
        - Instantiate the model
        - Set model to evaluation mode.

        See https://pytorch.org/tutorials/beginner/saving_loading_models.html#saving-loading-a-general-checkpoint-for-inference-and-or-resuming-training

        :param model_file: file containing the model
        """
        checkpoint = torch.load(model_file)
        n_dims = checkpoint[N_DIMS_KEY]
        hidden_size = checkpoint[HIDDEN_SIZE_KEY]
        n_classes = checkpoint[N_CLASSES_KEY]

        self.model = FeedForwardNet(n_dims, hidden_size, n_classes)
        self.model.load_state_dict(checkpoint[MODEL_STATE_KEY])
        self.model.eval()

    def load_data(self, data_file):
        """
        Load the evaluation tensors in data_file, where data_file
        is as generated by Preprocessor.save_tensors().
        Set self.X_test, self.y_test, and self.label_map.

        Note: You can use torch.load() here.

        :param data_file: file containing test data as tensors
        """
        data = torch.load(data_file)
        self.X_test = data[X_KEY]
        self.y_test = data[Y_KEY]
        self.label_map = data[MAP_KEY]
        

    def evaluate_model(self):
        """
        Evaluate the model loaded in load_model using the evaluation
        data loaded by load_data().
        Return two reports generated by the
        sklearn.metrics.classification_report package:

        - report dictionary
        - report as a string

        You will need the label_map to generate the *target_names* for the
        classification_report() function.

        Note: It is important that gradient calculation is turned off during
        evaluation. This can be done by getting the model predictions
        in a **with torch.no_grad():** block.

        :return dict, str: evaluation report as dictionary and as string
        """
        with torch.no_grad():
            outputs = self.model(self.X_test)
            _, predicted = torch.max(outputs, 1)
            target_names = [label for label, _ in sorted(self.label_map.items(), key=lambda item: item[1])]
            report_dict = classification_report(self.y_test.cpu(), predicted.cpu(), target_names=target_names, output_dict=True)
            report_str = classification_report(self.y_test.cpu(), predicted.cpu(), target_names=target_names)
            return report_dict, report_str


if __name__ == '__main__':
    """
    Evaluate the following:
    
    - baseline model on the dev data
    - baseline model on the test data
    - Your best model, generated by grid search, on dev data
    - Your best model, generated by grid search, on test data
    """
    evaluator = Evaluator()

    # Evaluate baseline model on dev data
    evaluator.load_model('Models/baseline-model-given.pt')
    evaluator.load_data('dev_tensor_file.pt')
    dev_report_dict, dev_report_str = evaluator.evaluate_model()
    print("Baseline model on dev data:\n", dev_report_str)

    # Evaluate baseline model on test data
    evaluator.load_data('test_tensor_file.pt')
    test_report_dict, test_report_str = evaluator.evaluate_model()
    print("Baseline model on test data:\n", test_report_str)

    # Evaluate best model (generated by grid search) on dev data
    evaluator.load_model('Models/best.pt')
    evaluator.load_data('dev_tensor_file.pt')
    best_dev_report_dict, best_dev_report_str = evaluator.evaluate_model()
    print("Best model on dev data:\n", best_dev_report_str)

    # Evaluate best model (generated by grid search) on test data
    evaluator.load_data('test_tensor_file.pt')
    best_test_report_dict, best_test_report_str = evaluator.evaluate_model()
    print("Best model on test data:\n", best_test_report_str)
